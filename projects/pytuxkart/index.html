<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> PyTuxKart Ice-Hockey Game | PoJen Wang </title> <meta name="author" content="PoJen Wang"> <meta name="description" content="Playing PyTuxKart Ice-Hockey Game with Image-Based Agent"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nez0b.github.io/projects/pytuxkart/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "PyTuxKart Ice-Hockey Game",
            "description": "Playing PyTuxKart Ice-Hockey Game with Image-Based Agent",
            "published": "October 09, 2024",
            "authors": [
              
              {
                "author": "PoJen Wang",
                "authorURL": "https://nez0b.github.io",
                "affiliations": [
                  {
                    "name": "National Taiwan University",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Chang-Yu Cheng",
                "authorURL": "mailto:bricheng@utexas.edu",
                "affiliations": [
                  {
                    "name": "University of Texas, Austin",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">PoJen</span> Wang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>PyTuxKart Ice-Hockey Game</h1> <p>Playing PyTuxKart Ice-Hockey Game with Image-Based Agent</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#image-based-agent">Image Based Agent</a> </div> <ul> <li> <a href="#method-1-pointer">Method 1: Pointer</a> </li> <li> <a href="#method-2-heatmap">Method 2: Heatmap</a> </li> <li> <a href="#loss-function">Loss Function</a> </li> </ul> <div> <a href="#part-2-fixing-the-model">Part 2 Fixing the Model</a> </div> <ul> <li> <a href="#method-1-data-cartography">Method 1 Data Cartography</a> </li> <li> <a href="#method-2-training-the-adversarial-examples">Method 2 Training the Adversarial Examples</a> </li> <li> <a href="#method-3-fine-tuning-on-squad-v2-0">Method 3 fine-tuning on SQuAD v2.0</a> </li> </ul> <div> <a href="#conclusions">Conclusions</a> </div> </nav> </d-contents> <p><a id="fig:fcn"></a> <img src="/assets/img/pycart/arch.png" alt="Alt text" width="700"></p> <h2 id="introduction">Introduction</h2> <p>The task for this project is to program a SuperTuxKart ice-hockey player with the choice of either image-based agent or state–based agent. The objective of this hockey game is to score as many goals as possible in this 2 vs 2 tournament against the TA agents. We decided to build an image-based agent that takes the image as input and predicts the location of the puck and goal with two slightly different methods: The Pointer Method and The Heatmap Method. The reason we chose to use an image-based agent because we have been learning and processing the image with the model throughout the class. The project code repository is located at <a href="https://github.com/nez0b/ice-hockey" rel="external nofollow noopener" target="_blank">https://github.com/nez0b/ice-hockey</a></p> <h2 id="image-based-agent">Image Based Agent</h2> <p>The primary task for an image-based agent is to design a model that takes a player image as input and infer (1) whether targets (the puck and goals) are in the image (2) the location of the puck and goals. We proposed two methods that output the above information:</p> <ul> <li>Method 1 (<strong>The Pointer Method</strong>): The agent takes an input image and output two 2d pointer vectors of the puck and the (opponent’s) goal location. See <a href="#fig:fcn">Figure.1 </a> for the schematic plot. With the 2d pointer vectors, the controller and calculate the distance and the angles to the puck and the goal and drives the kart to these two positions.</li> <li>Method 2 (<strong>The Heatmap Method</strong>): The agent performs a object-detection task by learning the heatmap of the input image and infer the object locations and size.</li> </ul> <h3 id="model-architecture">Model Architecture</h3> <p>For each method, we preprocess the image data and learn the features using the same model architecture. We use a Fully Convolutional Network (FCN) with each individual blocks that use residual connections to avoid vanishing gradients. The architecture first uses four down-convolutional blocks where each block has two 3x3 convolutions followed by batch normalization and ReLU. Next, the architecture uses four up-convolutions to upscale the feature map back to the original dimension. Furthermore, we use skip connections between each pair of down-convolution and up-convolution to preserve the spatial information. Finally we connect this FCN to two different final layers that will output the desired shape for each methods. See <a href="#fig:fcn">Figure.1 </a> for a schematic plot of the model architecture. Next we discuss the details for these final layers.</p> <h3 id="method-1-pointer">Method 1: Pointer</h3> <p>In method 1, we connect the FCN network to a convolutional layer with four channels, which correspond to $(x_p, y_p, x_g, y_p)$, the x and y component of the pointer vectors from the kart to the puck (or the goal).</p> <h3 id="method-2-heatmap">Method 2: Heatmap</h3> <p>In method 2, we adapt the code from HW4 and connect the FCN network to a convolutional layer with five channels. The first three channels corresponds to the heatmaps for the puck and the two goal. The last channel corresponds to the size of the detections.</p> <h3 id="loss-function">Loss Function</h3> <p>The loss function for the method 1 network is the <code class="language-plaintext highlighter-rouge">MSELoss</code> between the network output $(x_p, y_p, x_g, y_g)$ and the true label:</p> \[l_{\text{method 1}} = \sum_{i\in (p, g)} \lvert x_i- x_i^* \rvert^2 + \lvert y_i- y_i^* \rvert^2\] <p>The loss function for the method 2 network is a combination of heatmap detection loss and the object size loss:</p> \[l_{\text{method 2}} = \text{BCELogitLoss()} + \text{(size weight)*MSELoss()}\] <p>To balance the heatmap and the size of the object, we choose the \textit{size weight} to be $\approx 0.0001$.</p> <p><img src="/assets/img/pycart/method1.png" alt="Alt text" width="700"></p> <h2 id="training-data-collection">Training Data Collection</h2> <p>We collect the gameplay data using the given <code class="language-plaintext highlighter-rouge">tournament/runner.py</code> script. For example, we execute <code class="language-plaintext highlighter-rouge">python -m tournament.runner AI AI -s ai_ai.pkl -f 5000 </code> to collect a game play between two “AI” agents and limit the number of frames to 5000 and save it to a pickle file.</p> <h3 id="method-1">Method 1</h3> <p>In method 1, for each image we calculate the pointer vector to the puck location (defined by $x_p, y_p$) and the pointer vector to the goal location (defined by $x_p, y_p$). These numbers can be calculated from the following game state data:</p> <ul> <li>Kart Location : 3d world coordinate of the kart</li> <li>Kart Front Location: 3d world coordinate of the kart front.</li> <li>Puck Location: 3d world coordinate of the puck</li> <li>Goal Location: The center of the goal $(0, 0, \pm 64.5)$</li> </ul> <p>Next the pointer function can be calculated from “Target vector - Kart vector”, where the target vector is “Puck(Goal) location - Kart Location” and the Kart vector is “Kart front - Kart Location”.</p> <h3 id="method-2">Method 2</h3> <p>For method 2, we calculate the true object location and size on the 2d projection view of the player. The conversion from a 3d world coordinate to the 2d projection view is given by:</p> \[x_{2d} = \mathcal{V}\cdot \mathcal{P} \cdot [x_{3d}, 1]^T\] <p>Here $\mathcal{P}$ is the 4d projection matrix, $\mathcal{V}$ is the 4d view matrix. $x_{3d}$ is the 3d world coordinate of an object. Finally the first two entries of $x_{2d}$ would be the x and y coordinate of the object projection. Given this formula we can calculate the location and the bounding boxes of the object in player’s view. See <a href="#fig:kart_det">Figure.2 </a> for an example of the object location and size.</p> <p>Next we take the object location and size, and convert them to the heatmap using the <code class="language-plaintext highlighter-rouge">detection_to_heatmap</code> function in the code. See <a href="#fig:heatmap">Figure.3 </a> for an example heatmap.</p> <p><a id="fig:kart_det"></a> <img src="/assets/img/pycart/image_boxes.png" alt="Alt text" width="700"></p> <p><a id="fig:heatmap"></a> <img src="/assets/img/pycart/image_hm.png" alt="Alt text" width="700"></p> <h2 id="controller-design">Controller Design</h2> <h3 id="method-1-1">Method 1</h3> <p>Given the output $(x_p, y_p, x_g, y_g)$ of the network, we can calculate the distance and the angle to the puck and the goal. The controller algorithm works as follows:</p> <ul> <li>if the distance to the puck is larger the size of the puck, we drive the kart to the puck</li> <li>After reaching the puck, we drive the kart toward the goal location.</li> </ul> <h3 id="method-2-1">Method 2</h3> <p>The output of the network in method 2 is a heatmap that detects the locations and the size of the puck and the goals. Next, we use <code class="language-plaintext highlighter-rouge">extract_peak</code> function from HW4 to find the locations of the puck and the goal on the 2d player’s view. With these information, we can infer (1) whether or not the object is in the player’s view (2) The 2d location of the object. Our controller logic works as follows:</p> <ul> <li>Detect if the puck is in the player’s view. If not, set the acceleration to zero and set the brake to <code class="language-plaintext highlighter-rouge">True</code> to reverse the direction of the kart.</li> <li>If the puck is in the player’s view, set the <code class="language-plaintext highlighter-rouge">steer</code> to the x coordinate of the puck’s detection location.</li> <li>Repeat the same player’s logic, but replace the puck detection with the goal location.</li> </ul> <h2 id="experiment">Experiment</h2> <h3 id="training">Training</h3> <p>We collect the training data using the given <code class="language-plaintext highlighter-rouge">tournament/runner.py</code> script. We execute <code class="language-plaintext highlighter-rouge">python -m tournament.runner AI AI -s ai_ai.pkl-f 5000</code> to collect the game state data of 5000 frames, which corresponds to 20000 labeled images. We also implement the image augmentation pipeline consists of randomly changing the brightness, contrast, saturation, and the hue of images to prevent over-fitting.</p> <h3 id="evaluation-method-and-result">Evaluation Method and Result</h3> <p>We used the loss from each loss function and the score running against the graders as the metrics. The losses of both methods were both high, meaning the model has deviation between the predicted values and label values. Then we run these methods against the local grader and online grader. Scoring higher score on local and online grader generally indicate the method is performing better.</p> <h3 id="result">Result</h3> <p>The results are summarized in <a href="#tab1">Table1</a>. The result for Method 1 does not perform well against local and online grader, scoring 32 out of 100 against both graders. Method 2 generally performs a better job against the local grader and online grader than Method 1. We also make the agents simply run straight, with maximum acceleration and no steering. Interestingly, even though Method 2 performed better than the agent cruising straight against the local grader, the result did not reflect on the online grader. The agent that simply cruising straight with no steering performed better against the online grader, yielding the highest score which we used this as our final submission.</p> <p><a name="tab1"></a></p> <table> <thead> <tr> <th>Method</th> <th>Local Grader</th> <th>Online Grader</th> </tr> </thead> <tbody> <tr> <td>Method 1</td> <td>$32 \%$</td> <td>$32 \%$</td> </tr> <tr> <td>Method 2 (First attempt)</td> <td>$47 \%$</td> <td>$12 \% $</td> </tr> <tr> <td>Method 2 (Second attempt)</td> <td>$44 \%$</td> <td>$38 \%$</td> </tr> <tr> <td>Agent cruising straight (First attempt)</td> <td>$40 \%$</td> <td>$44 \%$</td> </tr> <tr> <td>Agent cruising straight (Second attempt)</td> <td>$40 \%$</td> <td>$51 \%$</td> </tr> </tbody> </table> <p><strong>Table 1</strong> Scores of each method against local and online grader</p> <h2 id="alternative-method">Alternative Method</h2> <p>The results of both the methods do not perform as intended and score below $70 \%$. However, instead of coming up with a completely different approach as alternative, our team suggest that the heatmap method is feasible and could performed better if we can improve in the following areas:</p> <ul> <li>Data collection : We can collect more game play data against different TA agents for more rounds to better train the model for detection. We can also exclude bad data and images when the kart crashes on the wall.</li> <li>Field of view : The kart’s camera is one of the challenge for this project. We can consider and conduct more research on the field of view of the kart and image in training and detecting.</li> <li>Controller strategy : We can design a better approach when the puck is not in the player’s view. For example, instead of simply reversing the direction of the kart, we can enable communication between two karts to exchange puck location.</li> </ul> <h2 id="conclusions">Conclusions</h2> <p>Neither the pointer method nor the heatmap method performed well in this project. Both approaches scored lower than the agents that simply cruise straight with not steering against the online grader. If we can change one thing for this project, we should have spent less time working on Method 1, and spend more time to explore Method 2 where the agents can better detect the puck and goal from the heatmap, and improve the areas in data collection, field of view, and controller strategy.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2024-07-dataset-artifact.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 PoJen Wang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-kmeans-clustering-algorithm-with-cuda",title:"Kmeans Clustering Algorithm with CUDA",description:"Kmeans Clustering Algorithm with CUDA and CUDA Thrust API",section:"Posts",handler:()=>{window.location.href="/blog/2024/Kmeans/"}},{id:"post-quantum-transfer-learning",title:"Quantum Transfer Learning",description:"Quantum transfer learning with quantum pooling layer",section:"Posts",handler:()=>{window.location.href="/blog/2023/qnn-transfer/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"projects-dataset-artifacts-in-language-models",title:"Dataset Artifacts in Language Models",description:"Mitigating Dataset Artifacts with Adversarial Datasets and Data Cartography",section:"Projects",handler:()=>{window.location.href="/projects/data-artifact/"}},{id:"projects-pytuxkart-ice-hockey-game",title:"PyTuxKart Ice-Hockey Game",description:"Playing PyTuxKart Ice-Hockey Game with Image-Based Agent",section:"Projects",handler:()=>{window.location.href="/projects/pytuxkart/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%70%6A%77%61%6E%67@%70%72%6F%74%6F%6E%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=m5l-w84AAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/nez0b","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/po-jen-wang-49a37855","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/nejopw","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>